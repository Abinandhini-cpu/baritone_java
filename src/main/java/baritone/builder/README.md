This is where I am working on a rewrite from-scratch of the Baritone schematic builder.

I will write more documentation eventually, I have some planning documents that I may eventually paste into here and such, I just don't want to commit to writing about something when it's still up for change :)

The current Baritone BuilderProcess has a number of issues, no one disagrees there. The question is whether to try and fix those issues, or to start from scratch. I believe that starting from scratch is a good idea in this case. The reason is that I want to change the fundamental approach to building schematics. The current approach is basically "do whatever places / breaks I can from wherever I happen to be at the moment" and also "and if I can't work on anything from here, pathfind to a coordinate where I probably will be able to". This suffers from an inherently unfixable problem, which is that **there is no plan**. There are an untold number of infinite loops it can get stuck in that I have just hack patched over. Did you know that whenever the builder places a block, it increments a counter so that for the next five ticks (0.25 seconds) it won't consider breaking any blocks? This was my fix for it just placing and breaking the same block over and over. Did you know that the builder only places blocks at or below foot level purely because otherwise it would stupidly box itself in, because it isn't thinking ahead to "if I cover myself in blocks, I won't be able to walk to the next thing I need to do". And this doesn't even get into the larger scale infinite loops. I patched over the short ones, where it gets itself stuck within seconds, but the long term ones are a different beast. For example, the pathfinder that takes it to the next task can place / break blocks to get there. It has strict penalties for undoing work in the schematic, of course, but sometimes that's the only way forward. And in that scenario, it can cause infinite loops where each cycle lasts 30+ seconds ("nothing to do here, let's pathfind to the other side of the schematic" -> break a block in order to get there -> arrive at the other end -> "whoa i need to go place that block" -> walk back to where it started and place that block -> repeat the cycle).

So the idea, as you might have guessed from that foreshadowing, is that the new builder will generate a **complete** plan that includes interspersed actions of placing blocks and moving the player. This plan will be coherent and will not suffer from the issues of the current pathfinder in which costs are unable to take into account the previous actions that have changed the world. I'll say more on that later. This does mean that the schematic builder will not use the same path planner as the rest of Baritone.

Current restrictions that the builder will have, at least initially:
* No breaking blocks. If you want to `cleararea` you can just use the old one, it works fine for that specific thing, at least.
* For that reason, the schematic area should be clear. Think of this like a 3d printer going from bottom to top. It takes in a schematic, generates a plan of how to build it, and executes it.
* Because it generates a full plan, if you think about it, this means that your schematic needs to be plannable. Therefore, if your schematic has something unplaceable in it, it won't even begin to do anything. I'll probably add an option to just skip impossible blocks with a warning. But plan for certain things (e.g. lava) to not be possible.
* Ancillary only placed old-baritone-style to assist in movement

This is less dependent on Minecraft code. I'm too annoyed by things like `IBlockState` -> `BlockState` or `player.motionY()` -> `player.getMotion().y` or `== Blocks.AIR` -> `instanceof BlockAir`. For now, I've put everything that imports from Minecraft code into a subpackage called `mc`. I will probably stick with that. Basically I hate having to change all the stupid mapping names and deal with merge conflicts on those. For that reason I plan to use `int` instead of `IBlockState` everywhere, and basically do like `cachedData[state].isAir` instead of `state.getBlock() instanceof BlockAir` (so like `cachedData` would be a `BlockStateCachedData[]` with one entry per valid `IBlockState`). Then, for different versions of the game, all that would need to change is the code to populate array. This should help with checks like can-walk-on and can-place-against.

If all the blocks that existed in Minecraft were solid, can-walk-on, can-place-against, this would be trivially easy. (I know - even for schematics of blocks like that, the current builder has problems.) Even for blocks such as glazed terracotta that have orientation, it would be okay.

The problem arises with all these blocks that people love to use in builds that are really frustrating to work around. I'm referring to slabs, stairs, fences, walls, etc.

The current pathfinder makes a naive assumption that every movement's starting point is sane. In other words, it assumes that the previous movement will have gotten the player to the starting point stably. So even if the starting point is currently underground, the previous movement will have broken the two blocks that the player is now assumed to be standing in. If the starting point is floating in midair, the previous movement must have gotten a block placed that the player is currently standing on. This allows for incredibly fast long distance pathing. However, that isn't the goal here. In normal Baritone pathfinding, the goal is to get from point A to point B. Placing and breaking blocks along the way is only done as necessary to accomplish the first goal. Whereas in structure building, it's to place and break blocks, to realize a schematic. The player moving around is only done as necessary to accomplish the first goal. So, clearly, the builder pathfinder needs to be smarter than this. In order to generate these plans, it does need to be answer hypotheticals like "by this point in the schematic, if I stood here, could I reach this face of this block to complete this placement?". It also needs to be able to answer questions like "I'm standing at XYZ. But what am I actually standing on? At this point in the construction, is that a scaffolding throwaway block, or is it the half slab that we eventually intend to be placed here?". Therefore, a standard pathfinder, where a node is uniquely identified by its coordinate, will not be sufficient, as that doesn't convey any information about actions taken to the world up to that point. ~~If we want to use a traditional graph search pathfinder,~~ a node must actually be identified by the XYZ of the player and the set of blocks that have been modified so far.

~~I don't want to go too much further into how a traditional graph search algorithm could work here, as I'm not even certain that's what would work best. I'm considering STAN (an offshoot of graphplan) as well. It might be a hybrid solution, who knows. (e.g. try naive DFS, if that can't find a plan after X milliseconds, then fall back to graphplan).~~

I'm not sure how to think about performance for this. Obviously there are copes like "pregenerate a plan for a schematic, reuse it". There are also copes like "just throw it in another thread, who cares how long it takes". Because if I dump in a 128x128x128 schematic of all stone (two million blocks), it takes a few seconds to separate the strongly connected components. Is that okay? I think it is. Lol.

One particularly annoying thing is needing to reimplement portions of Minecraft. For example, there is a bit of code that I can easily call that says "If I looked in this direction right now, and right clicked, what block precisely would it place". Because, well, Minecraft needs to decide what block appears if and when I right click. This works great for current Baritone and I can just call it without needing to worry. For this builder though, I need to do hypotheticals. "If I were standing here on top of this block (that doesn't exist yet), looking at this face of this block (which doesn't exist yet), and right clicked while holding this item (which I don't have), what block would appear?". Minecraft code isn't built like that. There are so many conditions based on Y hit, face hit, player orientation, etc. Just look at the trapdoor place logic to instantly die. So I need to reimplement all the code for "I desire this block state (northward facing upside down acacia stairs). How can I make this coordinate contain that block? (well, you need to be facing north and right click the top face of an adjacent block with such a stair)". That code needs to be written for every block that has custom placement like that. The question of "If block X is at coordinate Y, could I right click against that to place block Z on face D" is incredibly frustratingly not easily answerable. It all depends on external variables like the horizontal orientation of the player, and even the Y coordinate of the player (for some blocks like pistons and dispensers). 

I'm trying my best to minimize floating point calculations as much as possible. The fast case for the graph search should never use floating point. I'm too annoyed by even simple things like `> 1` being randomly wrong (with `0.99999` or `1.000001`). Also, no need to have path costs be floating point. Both path costs and player Y will be fixed point integers. Costs have a to-be-determined denominator, for player Y it's sixteen.

I'm going to list stupid things about Minecraft that have pissed me off during this:
* Every `IBlockState` in the game has an entry in `Block.BLOCK_STATE_IDS`. Except for some variants of tripwire. Nothing else. Just tripwire is the exception. And it isn't even for a good or elegant reason. It's just hardcoded in the thing that constructs the block state registry to skip some of the tripwire states. No idea why.
* `Block.BLOCK_STATE_IDS` has double entries. There are many states that map to the same integer ID, when you go back to states it sets certain properties to default. Such as `BlockStairs.SHAPE`.

Things about old Baritone builder that are stupid and that I will do better:
* The thing I mentioned above about left and right clicking
* Complete nonunderstanding of orientable blocks. It has no idea that in order to place a stair / a torch it has to go walk around and look at the block from the other side.
* Instead of just placing blocks normally, it sneaks before EVERY right click. This makes it look unnatural, stupid, and jittery, for no reason.

The area shall be combined with the schematic in the following way:
* The entire buildable area is considered to be "part of the schematic"
* The working space will be that area. The pathfinder's universe ends at the border of that area.
* The current status is therefore defineable as the schematic, the set of block positions that are "intended scaffolding", and the set of block positions that have been placed (air is interpreted as scaffolding whether intended or not)
  * Needed because the scaffolder is not magic, it's possible that the solver needs to place additional scaffolding in order to reach something
  * There are no further possible options beyond those (want air have air, want scaffolding have air, want air have scaffolding, want block have air, want block have block)
  * Blocks that are desired to be not-air that are currently a different block are disallowed (for the time being) (because that would require breaking blocks)
  * Not yet decided if the schematic itself is allowed to have throwaways. Probably should be allowed, it would be indicative of bad design if it weren't allowed.

# How will it work

I'm going to boldly write down the current plan. The above part of the readme ^ was all written in 2021 when I was just getting started and didn't really have a well-formed solution to how this mystical schematic building plan would be generated in the first place.

## The preprocessing

We load the schematic from disk and probably do some basic checks that it doesn't have any impossible blocks in it.

First, we create the [place order dependency graph](https://github.com/cabaletta/baritone/blob/a9d6aaebf3f72c7af8e8fe550a1c8cdd36b96fef/src/main/java/baritone/builder/PlaceOrderDependencyGraph.java). This is a simple 3d voxel grid that stores six bits per blockpos in the schematic, representing what blocks have to be placed before this one. For a normal block, in theory all six could be on. (in practice, baritone 2 will probably never place top-to-bottom, so in practice it'll only ever use five of those six). For something like a torch, only one will be on, representing how the torch depends on the block it'll be placed against. Sand will have only the DOWN bit on, because if you tried to place the sand before that block that supports it, it would just fall. In short, this graph represents the dependencies of placing the blocks of the schematic. Each bit that's on means that this block *could* be placed against that face, therefore we assume that once any of those faces are placed, this block can be placed next. This calculation is pretty complicated and involves checking both the block and the one it would hypothetically be placed against. For example, bottom slabs can be placed against upside-down stairs... but only if the stair is facing away from the side you want to place the slab against (yes it does take that into account, see [here](https://github.com/cabaletta/baritone/blob/a9d6aaebf3f72c7af8e8fe550a1c8cdd36b96fef/src/main/java/baritone/builder/mc/BlockStatePropertiesExtractor.java#L48-L69)).

A [few basic checks](https://github.com/cabaletta/baritone/blob/a9d6aaebf3f72c7af8e8fe550a1c8cdd36b96fef/src/main/java/baritone/builder/DependencyGraphAnalyzer.java) are run against the place order dependency graph, namely that every block can be placed from at least one side, then we check that there is some hypothetical placeable route from the boundary of the schematic to everything in the interior. This catches cases such as shulker boxes placed against each other, where you need one already there to place the other, but that other one also needs the first one (baritone 2 won't support this since it makes the code much easier). Also you might be wondering, "what do you mean placeable route from the boundary? isn't the schematic air? air isn't placeable". The PlaceOrderDependencyGraph treats air as scaffolding, because, it could be. The alternative is just to have no data in the air parts, which is boring. In practice, this is useful for the next step because the scaffolder might need to add scaffolding to the build.

## Scaffolding

In Minecraft, blocks have to be placed against other blocks. You can't make one appear way up in the air, you can only make one appear next to an existing block. Therefore, we are going to add a reasonable and hopefully nearly minimal quanity of scaffolding blocks to the schematic so that the entire thing is placeable from a single starting point (which will be at the very bottom, due to how (as mentioned earlier) the dependency graph never points downward, only upward or sideways (this is due to the fact that builds are completed in survival mode and Steve can't fly so he has to walk on top of what he's building)).

To accomplish this, first the the place order dependency graph is analyzed using [Tarjan's algorithm](https://github.com/cabaletta/baritone/blob/a9d6aaebf3f72c7af8e8fe550a1c8cdd36b96fef/src/main/java/baritone/builder/TarjansAlgorithm.java) to find the strongly connected components, which are collapsed into single nodes within a collapsed dependency graph (which is now a DAG since all the cycles are collapsed), maintained within a [dependency graph scaffolding overlay](https://github.com/cabaletta/baritone/blob/a9d6aaebf3f72c7af8e8fe550a1c8cdd36b96fef/src/main/java/baritone/builder/DependencyGraphScaffoldingOverlay.java). This means the sections of the schematic in which every block can be placed starting from any of them. That's a bit hard to understand but don't worry about it because in practice, most builds will be mostly comprised of normal blocks that can be placed from any direction, so in practice these collapsed components will be just horizontal slices of the build. But, they won't contain air gaps. (example: if your schematic is a simple tower, each y level gets its own slice. if your schematic is two disconnected towers, there will be two slices at each y level, one for each tower). When I say "slice" or "collapsed component" or "strongly connected component" or just "component", that all means the same thing. Basically like Baritone's existing buildInLayers, except the layers are also split sideways at each air gap.

The point of doing this is that we can very simply and easily tell where scaffolding should go by looking at the collapsed dependency graph. The algorithm is now actually very simple: look at every component that has no incoming edges (called a "root component"). (there will always be at least one since this graph is acyclic) Those are the component(s) that we'd need to "start with". Because we can't (yet) place them starting anywhere else. So, we add scaffolding until there is only one such root component. The actual algorithm for this is not yet fully nailed down. But probably something simple like "pick the root component with the highest Y level then Dijkstra outwards and downwards until you find another component, then add scaffolding along that path" will work fine. Or it might be more complicated (simultaneous Dijkstra from every starting source). Note that this is guaranteed to succeed because of the preprocessing which checked that the build is placeable from the exterior.

As the scaffolder decides where to place scaffolding, it updates the dependency graph scaffolding overlay. But, rerunning Tarjan's algorithm each time would be very slow (it's `O(blocks)`). Instead, it detects the new edges added to the graph and updates accordingly. If there are any cycles created (aka strongly connected components), they are collapsed in real time as the scaffolding is placed. This is actually pretty fast because under the "no downward placement" assumption, cycles can only really be created on the same y level, and complicated collapsed graphs on the same y level are probably not going to come up much. You'd have to have some borderline malicious schematic full of directional blocks like hoppers or shulkers or logs or something for this to actually be an issue.

When the scaffolder is done and all the necessary scaffolding is added to the overlay, we now have a beautiful DAG representing how we're going to build the schematic. There is one root node at the bottom of the build with no incoming edges, and outward edges go upwards connecting the entire build. (note: even though there are no cycles, there can still be diamond shapes (A->B A->C B->D C->D), which ends up being [super annoying](https://github.com/cabaletta/baritone/blob/a9d6aaebf3f72c7af8e8fe550a1c8cdd36b96fef/src/main/java/baritone/builder/DependencyGraphScaffoldingOverlay.java#L242-L288)). Each node represents a component aka slice of the build, and every one of those components is a connected set of blocks all at the same y level. The idea is that once we've got any one of the blocks in a component placed, we can get the rest of them placed (this is how they were computed in the first place, from the place order dependency graph).

## Planning

The crux of the matter is that the Minecraft player can't fly or teleport in survival mode. If you were in creative mode, this would be no trouble at all, just do it like a 3d printer bottom to top. But alas, we have to walk on top of the build while we're building it.

Therefore, it's critical to keep track of the area where the player can walk around. We need to be able to frequently and efficiently answer the question "Is it okay to place this block? Or would that get me stuck and unable to walk onwards?"

The idea here is a data structure that enables [dynamic connectivity](https://en.wikipedia.org/wiki/Dynamic_connectivity), specifically the level structure on top of Euler Tour Forests. This is a data structure that accepts information such as "vertex v and u are now linked by an edge" and "that edge has now been cut" in any order, taking amortized `O((log n)^2)` time. It is able to answer queries of whether v and u are connected by any path also in amortized `O((log n)^2)` time. This is *mind boggling*. Even if you have some incredibly complicated grid with millions of nodes, it can tell you whether a path exists in polylog time. And, even more incredibly, if you remove an edge, the structure updates *also in polylog time* and future queries will reflect that reality (those components are now disconnected if that was the only link, or if there was another link that one is being used now). Here are some links: [wiki](https://en.wikipedia.org/wiki/Dynamic_connectivity#The_Level_structure), [wiki2](https://en.wikipedia.org/wiki/Euler_tour_technique#Euler_tour_trees), [the paper that invented this particular structure (with these deterministic runtimes), see sections 2, 2.1, 3, 3.1, 3.2](https://u.cs.biu.ac.il/~rodittl/p723-holm.pdf).

The builder is able to treat this mostly as a black box, an API that exposes `Link(u,v)` `Cut(u,v)` and `Is-Connected?(u,v)`. You don't really need to understand how the euler tour forest works. But the basic idea is to maintain a minimum spanning tree of every graph in the forest, maintain an euler tour on each such graph, and store each euler tour in a balanced binary search tree. e.g. if you had nodes A,B,C with connections AB and BC, the euler tour could look like `(a,b) (b,c) (c,b) (b,a)`. It's very important to note that the tour can go in any order. For example you can "cut the deck" and move the first element of the tour to the back, or vice versa, and it's still perfectly valid. The rule is just that the euler tour will go along each edge twice (once in each direction). The way to tell if two nodes have any path between them is by finding which euler tour each is in - if they're both in the same tour, there is a path between them. When linking two nodes U and V that previously had no path between them, the idea is that you grab the euler tour for both, "cut the deck" so that one begins and ends at U, and the other begins and ends at V, then connect them with the new edge. So, like `"previous tour rotated to start and end at U" + [(U,V)] + "the other previous tour rotated to start and end at V" + [(V,U)]`. (these tours were separate, now they're combined). When cutting an edge, it's a bit more complicated because you have to search for whether there's some other edge that can keep these two components connected by another route, but anyway if you don't find one, you just do the opposite (find the `(V,U)` and the `(U,V)` and snip the tour into half at those places, rotating so that one is at the beginning so you get two pieces not three). You could do this with the tour being stored in a simple `ArrayList<Edge>`  for sure, but it would have very bad performance, we can do better. Instead, we use a balanced binary tree (specifically a [red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)). It's sortof interesting - we aren't actually storing any data in the tree, the nodes don't actually have any kind of "order" that is being maintained. All the tree is being used for is maintaining the structure (the pointers and the red/black colors). With this structure, operations such as "cut off all elements before this one, and move them to the back" can be done in `O(log n)` time (as well as the simple operations like insert and delete too) (whereas an ArrayList would take `O(n)` for split / concat). There is an additional `O(log n)` term, as we do some trickery with levels - we actually store `log n` copies of this entire data structure, with the maximum size cut in half each time. We need to do that so `Cut` isn't `O(n)`, because `Cut` needs to find an alternate edge if it exists whenever you try and disconnect two components. I'm not going to explain it but take a look at the previous links or [this lecture which covers it](https://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/17/Small17.pdf).

The one thing you DO need to know is that we can attach arbitrary data to these trees. As a simple example, each node could have attached to it a count of adjacent blocks that we still intend to place but haven't done so yet. Going up the red-black tree, we could code each node to sum the values of its child nodes. Now, we can look at where the player is standing, traverse the red black tree to the root and look at its count, and that'll let us check if there's still work to do in the area we're standing in. This becomes interesting when used as a hypothetical. For example, when we place a block that would cut off the area the player can walk into two pieces with no path between them anymore, we can notice "Hey, one of these has a remaining block count of 0. It's actually fine to cut off that area, because we're done there! We just need to make sure we're standing on the OTHER side when we place that block". This might not sound exciting but it really is because this is done in `O(log n)` time!!

This solves the "don't paint yourself into the corner" problem.

Baritone will be able to realize what block placements are "safe" (aka: don't affect the navigable surface (the area that it can walk around in)), and which ones require special conditions (aka: the ones that cut off the surface into two, three, or even four pieces). And the ones that require special conditions will be much easier to reason about (as described in the last paragraph).

We'll create a plan by having a list of slices that we're currently working on, starting with the root. When a slice is completed, there will be some logic to potentially unlock new slices (its children and maybe also grandchildren (under some conditions) in the collapsed dependency DAG). As blocks are placed, the navigable surface is updated in real time. Perhaps the rules can be relaxed and we can allow slight "working ahead" into slices that are up next, since we can tell when that would block off our future path or not! The navigable surface will be able to answer quickly "can I get next to this block so I can place it?". There will probably be complicated rules about when it is and isn't okay to cut off the walkable area. For example building any kind of pillar absolutely requires cutting it off. For example maybe it needs to look ahead, see what the build will look like once this offshoot tower is completed, and see if it can fall back down to where it was before? Maybe when it tries to place a block but decides no this one is for later it does exponential backoff and moves it further and further back in some priority queue? No idea :D


